<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans.xsd
                             http://www.springframework.org/schema/context
                             http://www.springframework.org/schema/context/spring-context-4.0.xsd">

  <!--Ищет бины в пакете с аннотациями: @Component, @Repository, @Service, @Controller-->
  <context:component-scan base-package="ru.edu"
  annotation-config="true"
  use-default-filters="false">
    <!--Ищем все аннотации @Component - по умолчанию поведение при true-->
    <context:include-filter type="annotation" expression="org.springframework.stereotype.Component"/>
    <!--все классы с интерфейсом CrudRepository создаются, как бин-->
    <context:include-filter type="assignable" expression="ru.edu.database.repository.CrudRepository"/>
    <!--все классы по регулярке в пакете ru.edu. с окончание на Repository создаются, как бин-->
    <context:include-filter type="regex" expression="ru\.edu\..+Repository"/>
  </context:component-scan>

<!--  &lt;!&ndash;подключаем настройки application.properties&ndash;&gt;-->
<!--  <bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">-->
<!--    &lt;!&ndash;в value через запятую указываем файлы с настройками&ndash;&gt;-->
<!--    <property name="locations" value="classpath:application.properties"/>-->
<!--  </bean>-->
  <!--вместо bean с PropertySourcesPlaceholderConfigurer,
  если в beans задан атрибут xmlns:context-->
  <context:property-placeholder location="classpath:application.properties"/>


  <!-- Пока закомментировали на будущее,
  т.к. не можем задать сложные типы в конструкторе через @Component -->
<!--  <constructor-arg name="args" type="java.util.List">-->
<!--    <list>-->
<!--      <value>&#45;&#45;arg1=value1</value>-->
<!--      <value>&#45;&#45;arg2=value2</value>-->
<!--      <ref bean="driver"/>-->
<!--    </list>-->
<!--  </constructor-arg>-->
<!--  &lt;!&ndash;DI через сеттер&ndash;&gt;-->
<!--  <property name="properties">-->
<!--    <map>-->
<!--      <entry key="url" value="postgresurl"/>-->
<!--      <entry key="password" value="123"/>-->
<!--      &lt;!&ndash;value-ref - ссылка на другой бин-->
<!--      value-ref="driver" - id бина&ndash;&gt;-->

<!--      &lt;!&ndash;#{} позволяет обращаться к бинам и писать по факту обычный java код&ndash;&gt;-->
<!--      <entry key="driver" value="#{driver.substring(3)}"/>-->
<!--      <entry key="test" value="#{driver.length() > 10}"/> &lt;!&ndash;Получим в test boolean&ndash;&gt;-->
<!--      &lt;!&ndash;можно к классам обращаться через T() внутри #{}. Пример: T(Math).random() &ndash;&gt;-->
<!--      <entry key="test" value="#{driver.length() > T(Math).random() * 10}"/>-->
<!--      &lt;!&ndash;парсим строку ${db.hosts} в массив строк&ndash;&gt;-->
<!--      <entry key="hosts" value="#{'${db.hosts}'.split(',')}"/>-->
<!--      &lt;!&ndash;обратились к свойствам системы&ndash;&gt;-->
<!--      <entry key="currenUser" value="#{systemProperties['user.name']}"/>-->
<!--    </map>-->
<!--  </property>-->

  <!--Пока не можем объявить второй бин ConnectionPool через @Component. На будущее -->
  <!--  <bean id="pool2" name="p4" class="ru.edu.database.pool.ConnectionPool"/>-->

  <!--Пока не можем объявить бин String через @Component. Он в ядре java
  На будущее -->
  <bean class="java.lang.String" id="driver">
    <!--используем переменные из application.properties через ${}-->
    <constructor-arg type="java.lang.String" value="${db.driver}"/>
  </bean>

</beans>